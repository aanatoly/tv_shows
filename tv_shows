#!/usr/bin/python

############################################
# Logging
############################################
import logging, sys, os
progname = os.path.basename(sys.argv[0])
def _init_log():
    name = progname
    log = logging.getLogger(name)
    log.setLevel(logging.INFO)
    # log.setLevel(logging.DEBUG)
    h = logging.StreamHandler()
    f = logging.Formatter("%(name)s (%(funcName)s:%(lineno)d) :: %(message)s")
    # f = logging.Formatter("%(message)s")
    h.setFormatter(f)
    log.addHandler(h)
    return log

log = _init_log()

############################################
# Argument parsing
############################################
import argparse
desc = '''Looks up new opisodes of tv shows'''
p = argparse.ArgumentParser(description=desc)
p.add_argument("--debug", help="debug mode", action="store_true")
p.add_argument("-n", help="exact show name, eg 'Black Sails'",
               dest="name", metavar='NAME')
p.add_argument("-a", help="scan all shows in db", dest="all",
               action="store_true")
p.add_argument("-i", help="db info", dest="info",
               action="store_true")
p.add_argument("-s", help="chack available subtitles", dest="subtitles",
               action="store_true")
p.add_argument("-b", help="open links in a browser", dest="browser",
               action="store_true")
p.add_argument("-t", help="show trends and popular TV shows", dest="trends",
               action="store_true")

args = p.parse_args()
if args.debug:
    log.setLevel(logging.DEBUG)

log.debug("Args: %s", args)

############################################
# Imports
############################################
import subprocess as sp
from bs4 import BeautifulSoup
import re
import zlib
import datetime, json, textwrap, string

############################################
# Config
############################################
uagent = 'Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:11.0) ' + \
         'Gecko/20100101 Firefox/11.0'
config_file = '~/.tv_shows'
config_file_real = os.path.expanduser(config_file)

default_xconf = {
    'browser' : 'firefox-bin',
    'torrent_dir' : '~/Downloads/torrents',
    'tvs' : {
        'Black Sails': 's01e05',
        'Elementary': 's02e15',
    }
}

def config_read():
    try:
        text = open(config_file_real, 'r').read()
    except:
        config_write_default("does not exists")
        exit(1)

    try:
        xconf = eval(text)
        k1 = sorted(xconf.keys())
        k2 = sorted(default_xconf.keys())
        if k1 != k2:
            raise Exception("wrong format")
    except:
        config_write_default("has wrong format", text)
        exit(1)
        
    ntvs = {}
    for tv in xconf['tvs']:
        ntv = string.capwords(tv)
        ntvs[ntv] = xconf['tvs'][tv]
    xconf['tvs'] = ntvs
    
    return xconf

def pprint_dict(d):
    return json.dumps(d, indent=4, sort_keys=True) + '\n'
    
def config_write(xconf):
    open(config_file_real, 'w').write(pprint_dict(xconf))

def config_write_default(msg, old_config = None):
    print "Config file %s %s." % (config_file, msg)
    if old_config:
        print "It's saved as %s" % (config_file + ".bak",)
        open(config_file_real + ".bak", 'w').write(old_config)
    print "New one was created, please edit it and run script again"
    config_write(default_xconf)


def update_tvs_from_dl(tvs):
    files = []
    torrent_dir = os.path.expanduser(xconf['torrent_dir'])
    for (dirpath, dirnames, filenames) in os.walk(torrent_dir):
        files.extend(filenames)
        files.extend(dirnames)
    files = [ f.replace("'", "") for f in files ]
    files = [ f.replace(".", " ") for f in files ]
    files = [ ' '.join(f.split()) for f in files ]

    for tv in tvs:
        rtv = '(?i)' + tv.replace("'", "") + '.*(S\d\dE\d\d).*'
        for f in files:
            m = re.search(rtv, f)
            if not m:
                continue
            ep_last = m.group(1).lower()
            if ep_last > tvs[tv]:
                log.debug('update %s to %s', tv, ep_last)
                tvs[tv] = ep_last


    
############################################
# Subtitles
############################################

def update_subtitles(name, tv):
    name = name.replace("'", "")
    update_subtitles_tv(name, tv)
    update_subtitles_episodes(name, tv)
    
def update_subtitles_tv(name, tv):
    global re_subtitles

    log.debug('%s', name)
    site = 'http://www.subtitleseeker.com'
    url = site + '/search/TV_TITLES/' + name
    cmd = [
        'wget', '--timeout=10', '--tries=2', '--max-redirect=1',
        '-q', '-O', '-',
        '--user-agent=' + uagent,
        '--referer=' + site, url
    ]
    try:
        html = sp.check_output(cmd, stderr = open('/dev/null', 'w'))
    except:
        print >> sys.stderr, '\n', site, 'is unavailable'
        return
        
    soup = BeautifulSoup(html)
    for d in soup.find_all('div', attrs={'class' : 'boxRows'}):
        try:
            a = d.div.a
            t = string.capwords(a.text).replace("'", "")
        except:
            continue
        log.debug("title '%s', href '%s'", t, a['href'])
        if t != name:
            continue
        tv['sub_url'] = a['href']
        break


re_subtitles = None


def update_subtitles_episodes(name, tv):
    global re_subtitles

    log.debug('%s', name)
    site = 'http://www.subtitleseeker.com'
    url = site + '/search/TV_EPISODES/' + name
    cmd = [
        'wget', '--timeout=10', '--tries=2', '--max-redirect=1',
        '-q', '-O', '-',
        '--user-agent=' + uagent,
        '--referer=' + site, url
    ]
    try:
        html = sp.check_output(cmd, stderr = open('/dev/null', 'w'))
    except:
        print >> sys.stderr, '\n', site, 'is unavailable'
        return
        
    if not re_subtitles:
        r = '(?i)(?P<name>.*)\s+\(\d\d\d\d\)\s+(?P<ep>S\d\dE\d\d)\s+' + \
            '(?P<sno>\d+)?\s+Sub'
        re_subtitles = re.compile(r)

    soup = BeautifulSoup(html)
    eps = tv['eps']
    for d in soup.find_all('div', attrs={'class' : 'boxRows'}):
        t = string.capwords(d.text).replace("'", "")
        # log.debug("%s", t)
        m = re_subtitles.match(t)
        if not m:
            continue
        log.debug("%s %s %s", m.group('name'), m.group('ep'), m.group('sno'))
        xname = string.capwords(m.group('name'))
        xep = m.group('ep').lower()
        xsno = m.group('sno')

        if name != xname:
            continue
        if not xep in eps:
            eps[xep] = new_ep()
        eps[xep]['has_sub'] = (xsno != '' and xsno != '0')

    
############################################
# Torrents
############################################
re_torrents = None

def update_torrents(name, tv):
    global re_torrents

    log.debug('%s', name)
    site = 'http://kickass.to'
    name = name.replace("'", "")
    url = site + '/usearch/' + name.replace(' ', '%20') + \
           '%20category%3Atv/'
    opts = '?field=time_add&sorder=desc'
    html = wget_kat(site, url) + wget_kat(site, url + opts)
    tv['torrent_url'] = url + opts
    
    if not re_torrents:
        re_torrents = '(?i)(?P<name>.*)\s+(?P<ep>S\d\dE\d\d)'
        re_torrents = re.compile(re_torrents)

    eps = tv['eps']
    soup = BeautifulSoup(html)
    for d in soup.find_all('div', attrs={'class' : 'torrentname'}):
        t = string.capwords(d.text).replace("'", "")
        # log.debug("%s", t)
        m = re_torrents.match(t)
        if not m:
            continue
        xname = string.capwords(m.group('name')).replace("'", "")
        xep = m.group('ep').strip().lower()
        # drop bogus episods, like sXXe99
        if int(xep[-2:]) > 90:
            continue
        if name != xname:
            continue
        log.debug('%s %s', xname, xep)
        if not xep in eps:
            eps[xep] = new_ep()
        eps[xep]['has_torrent'] = True

    
def wget_kat(site, url):
    cmd = [
        'wget', '--timeout=10', '--tries=2', '--max-redirect=1',
        '-q', '-O', '-',
        '--user-agent=' + uagent,
        '--referer=' + site, url
    ]
    html = sp.check_output(cmd, stderr = open('/dev/null', 'w'))
    try:
        d = zlib.decompressobj(16+zlib.MAX_WBITS)
        html = d.decompress(html)
    except:
        pass
    return html


############################################
# Trends
############################################
def get_trends():
    site = 'http://kickass.to'
    url = site + '/tv/'
    html = ''
    for p in ['', '2', '3', '4']:
        html += wget_kat(site, url + p)
    
    soup = BeautifulSoup(html)
    trends = {}
    for d in soup.find_all('a', attrs={'class' : 'cellMainLink'}):
        t = d.text.replace("'", "").replace(".", " ")
        log.debug('%s', t)
        t = re.sub('\WS\d\d.*', '', t)
        t = re.sub('HDTV.*', '', t)
        t = ' '.join(t.split())
        log.debug('%s', t)
        try:
            trends[t] += 1
        except:
            trends[t] = 1

    score = []
    for t in trends:
        score.append((trends[t], t))
    score = sorted(score, key = lambda k: (-k[0], k[1]))
    for t in score:
        print t[1], '--', t[0]
        
############################################
# Air dates
############################################
re_air_dates = None

def update_air_dates(name, tv):
    global re_air_dates
    
    site = 'http://www.tvrage.com'
    url = site + '/%s/episode_list/all'
    name = name.replace("'", "")
    name = name.replace(" ", "_")
    log.debug('%s', name)
    cmd = [
        'wget', '--timeout=10', '--tries=2', '--max-redirect=1',
        '-q', '-O', '-',
        # '--user-agent=' + uagent,
        '--referer=' + site, url % name
    ]
    # log.debug('wget %s', cmd)
    html = sp.check_output(cmd, stderr = open('/dev/null', 'w'))
    soup = BeautifulSoup(html)
    eps = tv['eps']
    if not re_air_dates:
        r = '(?i)\d+\s+(?P<s>\d+)x(?P<e>\d+)\s+(?P<d>\S+)'
        re_air_dates = re.compile(r)
        
    for d in soup.find_all('tr', attrs={'id' : 'brow'}):
        t = ' '.join(d.text.split())
        m = re_air_dates.match(t)
        if not m:
            continue
        ep = 's%02de%02d' % (int(m.group('s')), int(m.group('e')))
        try:
            d = datetime.datetime.strptime(m.group('d'), '%d/%b/%Y')
        except:
            d = None
        log.debug("%s %s", ep, d)
        if not ep in eps:
            eps[ep] = new_ep()
        eps[ep]['air_date'] = d
        


############################################
# Main
############################################

def new_tv_show():
    tv = dict()
    tv['eps'] = {}
    tv['torrent_url'] = ''
    tv['sub_url'] = ''
    tv['dl_ep'] = 's00e00'
    return tv

def new_ep():
    ep = dict()
    ep['air_date'] = None
    ep['has_torrent'] = False
    ep['has_sub'] = False
    return ep

def update_tv_show(name, tv):
    log.debug('%s', name)
    update_air_dates(name, tv)
    update_torrents(name, tv)
    if args.subtitles:
        update_subtitles(name, tv)
    
def print_tv_show(tv):
    msg_dl = tv['dl_ep']
    if msg_dl == 's00e00':
        msg_dl = ''

    # find new episodes
    eps = tv['eps']
    ep_ids = [ ep_id for ep_id in sorted(eps) if ep_id > tv['dl_ep']]
    log.debug('eps %s', ep_ids)
    if not ep_ids:
        return (msg_dl, '')

    # find new episodes with torrents
    ss = []
    for ep_id in ep_ids:
        if not eps[ep_id]['has_torrent']:
            continue
        s = ep_id
        if eps[ep_id]['has_sub']:
            s += ' + subs'
        ss.append(s)
    if ss:
        if args.browser:
            if tv['torrent_url']:
                sp.Popen([xconf['browser'], tv['torrent_url']],
                         stderr = open('/dev/null', 'r'))
            if tv['sub_url']:
                sp.Popen([xconf['browser'], tv['sub_url']],
                         stderr = open('/dev/null', 'r'))
        return (msg_dl, ', '.join(ss))

    # find date of the next episode
    today = datetime.datetime.today()
    # msg_next = 'Next ' + ep_ids[0]
    msg_next = ''
    d = eps[ep_ids[0]]['air_date']
    if d:
        # msg_next += ' at ' + str(d.date())
        days = (d - today).days + 1
        if days > 0:
            msg_next += 'in ' + str(days) + ' days'
        else:
            msg_next += 'soon'
    return (msg_dl, msg_next)

############################################
# Main
############################################
xconf = config_read()

if args.info:
    print config_file
    print pprint_dict(xconf)
    exit(0)

if args.trends:
    get_trends()
    exit(0)

tvs = {}

nlen = 0
if args.name:
    name = args.name
    name = string.capwords(name)
    nlen = len(name)
    tv = new_tv_show()
    tvs[name] = tv
elif args.all:
    update_tvs_from_dl(xconf['tvs'])
    config_write(xconf)
    for name in sorted(xconf['tvs']):
        if nlen < len(name):
            nlen = len(name)
        tv = new_tv_show()
        tv['dl_ep'] = xconf['tvs'][name]
        tvs[name] = tv

if not tvs:
    exit(0)
    
nlen += 3
afmt = '%-' + str(nlen) + 's' + '%-9s%s'
indent = ' ' * (nlen + 9)
tw = textwrap.TextWrapper(width = 78,
                          replace_whitespace = False,
                          subsequent_indent = indent)

print "\033[1m" + (afmt % ('TV', 'Old', 'New')) + "\033[0m"
for name in sorted(tvs):
    print name, " ",
    sys.stdout.flush()
    update_tv_show(name, tvs[name])
    msg = afmt % ( (name,) + print_tv_show(tvs[name]) )
    msg = "\033[" + str(nlen) + "D" + tw.fill(msg)
    print msg
