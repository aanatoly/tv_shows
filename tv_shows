#!/usr/bin/python

############################################
# Logging
############################################
import logging, sys, os
progname = os.path.basename(sys.argv[0])
def _init_log():
    name = progname
    log = logging.getLogger(name)
    log.setLevel(logging.INFO)
    # log.setLevel(logging.DEBUG)
    h = logging.StreamHandler()
    f = logging.Formatter("%(name)s (%(funcName)s:%(lineno)d) :: %(message)s")
    # f = logging.Formatter("%(message)s")
    h.setFormatter(f)
    log.addHandler(h)
    return log

log = _init_log()

############################################
# Argument parsing
############################################
import argparse
desc = '''Looks up new opisodes of tv shows'''
p = argparse.ArgumentParser(description=desc)
p.add_argument("--debug", help="debug mode", action="store_true")
p.add_argument("-n", help="exact show name, eg 'Black Sails'",
               dest="name", metavar='NAME')
p.add_argument("-a", help="scan all shows in db", dest="all",
               action="store_true")
p.add_argument("-i", help="db info", dest="info",
               action="store_true")
p.add_argument("-s", help="chack available subtitles", dest="subtitles",
               action="store_true")
p.add_argument("-b", help="open links in a browser", dest="browser",
               action="store_true")

args = p.parse_args()
if args.debug:
    log.setLevel(logging.DEBUG)

log.debug("Args: %s", args)

############################################
# Imports
############################################
import subprocess as sp
from bs4 import BeautifulSoup
import re
import zlib
import datetime, pprint, textwrap

############################################
# Config
############################################
uagent = 'Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:11.0) ' + \
         'Gecko/20100101 Firefox/11.0'
config_file = '~/.tv_shows'
config_file_real = os.path.expanduser(config_file)

default_xconf = {
    'browser' : 'firefox-bin',
    'torrent_dir' : '~/Downloads/torrents',
    'tvs' : {
        'Black Sails': 's01e05',
        'Elementary': 's02e15',
    }
}

def config_read():
    try:
        text = open(config_file_real, 'r').read()
    except:
        config_write_default("does not exists")
        exit(1)

    try:
        xconf = eval(text)
        k1 = sorted(xconf.keys())
        k2 = sorted(default_xconf.keys())
        if k1 != k2:
            raise Exception("wrong format")
    except:
        config_write_default("has wrong format")
        exit(1)

    return xconf

def config_write(xconf):
    open(config_file_real, 'w').write(pprint.pformat(xconf, width=20) + '\n')

def config_write_default(msg):
    print "Config file", config_file, msg
    print "New one was created, please edit it and run script again"
    config_write(default_xconf)


def update_tvs_from_dl(tvs):
    files = []
    torrent_dir = os.path.expanduser(xconf['torrent_dir'])
    for (dirpath, dirnames, filenames) in os.walk(torrent_dir):
        files.extend(filenames)
        files.extend(dirnames)
    files = [ ' '.join(f.replace('.', ' ').split()) for f in files ]

    for tv in tvs:
        rtv = '(?i)' + tv + '.*(S\d\dE\d\d).*'
        for f in files:
            m = re.search(rtv, f)
            if not m:
                continue
            ep_last = m.group(1).lower()
            if ep_last > tvs[tv]:
                log.debug('update %s to %s', tv, ep_last)
                tvs[tv] = ep_last


    
############################################
# Subtitles
############################################

def update_subtitles(name, tv):
    global re_subtitles

    log.debug('%s', name)
    site = 'http://www.subtitleseeker.com'
    url = site + '/search/TV_TITLES/' + name
    tv['sub_url'] = url
    cmd = [
        'wget', '--timeout=10', '--tries=2', '--max-redirect=1',
        '-q', '-O', '-',
        '--user-agent=' + uagent,
        '--referer=' + site, url
    ]
    html = sp.check_output(cmd, stderr = open('/dev/null', 'w'))

    soup = BeautifulSoup(html)
    for d in soup.find_all('div', attrs={'class' : 'boxRows'}):
        try:
            a = d.div.a
            t = ' '.join(a.text.split()).title()
        except:
            continue
        log.debug("title '%s', href '%s'", t, a['href'])
        if t != name:
            continue
        tv['sub_url'] = a['href']
        break


re_subtitles = None


def update_subtitles_old(name, tv):
    global re_subtitles

    log.debug('%s', name)
    site = 'http://www.subtitleseeker.com'
    url = site + '/search/TV_EPISODES/' + name
    tv['sub_url'] = url
    cmd = [
        'wget', '--timeout=10', '--tries=2', '--max-redirect=1',
        '-q', '-O', '-',
        '--user-agent=' + uagent,
        '--referer=' + site, url
    ]
    html = sp.check_output(cmd, stderr = open('/dev/null', 'w'))

    if not re_subtitles:
        r = '(?i)(?P<name>.*)\s+\(\d\d\d\d\)\s+(?P<ep>S\d\dE\d\d)\s+' + \
            '(?P<sno>\d+)?\s+Sub'
        re_subtitles = re.compile(r)

    soup = BeautifulSoup(html)
    eps = tv['eps']
    for d in soup.find_all('div', attrs={'class' : 'boxRows'}):
        t = ' '.join(d.text.split())
        # log.debug("%s", t)
        m = re_subtitles.match(t)
        if not m:
            continue
        log.debug("%s %s %s", m.group('name'), m.group('ep'), m.group('sno'))
        xname = m.group('name').title()
        xep = m.group('ep').lower()
        xsno = m.group('sno')

        if name != xname:
            continue
        if not xep in eps:
            eps[xep] = new_ep()
        eps[xep]['has_sub'] = (xsno != '' and xsno != '0')

    
############################################
# Torrents
############################################
re_torrents = None

def update_torrents(name, tv):
    global re_torrents

    log.debug('%s', name)
    site = 'http://kickass.to'
    url = site + '/usearch/' + name.replace(' ', '%20') + \
           '%20category%3Atv/'
    opts = '?field=time_add&sorder=desc'
    html = wget_kat(site, url) + wget_kat(site, url + opts)
    tv['torrent_url'] = url
    
    if not re_torrents:
        re_torrents = '(?i)(?P<name>.*)\s+(?P<ep>S\d\dE\d\d)'
        re_torrents = re.compile(re_torrents)

    eps = tv['eps']
    soup = BeautifulSoup(html)
    for d in soup.find_all('div', attrs={'class' : 'torrentname'}):
        t = ' '.join(d.text.split())
        # log.debug("%s", t)
        m = re_torrents.match(t)
        if not m:
            continue
        xname = m.group('name').strip().title()
        xep = m.group('ep').strip().lower()
        # drop bogus episods, like sXXe99
        if int(xep[-2:]) > 90:
            continue
        if name != xname:
            continue
        log.debug('%s %s', xname, xep)
        if not xep in eps:
            eps[xep] = new_ep()
        eps[xep]['has_torrent'] = True

    
def wget_kat(site, url):
    cmd = [
        'wget', '--timeout=10', '--tries=2', '--max-redirect=1',
        '-q', '-O', '-',
        '--user-agent=' + uagent,
        '--referer=' + site, url
    ]
    html = sp.check_output(cmd, stderr = open('/dev/null', 'w'))
    try:
        d = zlib.decompressobj(16+zlib.MAX_WBITS)
        html = d.decompress(html)
    except:
        pass
    return html

############################################
# Air dates
############################################
re_air_dates = None

def update_air_dates(name, tv):
    global re_air_dates
    
    site = 'http://www.tvrage.com'
    url = site + '/%s/episode_list/all'
    name = '_'.join(name.title().split())
    log.debug('%s', name)
    cmd = [
        'wget', '--timeout=10', '--tries=2', '--max-redirect=1',
        '-q', '-O', '-',
        # '--user-agent=' + uagent,
        '--referer=' + site, url % name
    ]
    # log.debug('wget %s', cmd)
    html = sp.check_output(cmd, stderr = open('/dev/null', 'w'))
    soup = BeautifulSoup(html)
    eps = tv['eps']
    if not re_air_dates:
        r = '(?i)\d+\s+(?P<s>\d+)x(?P<e>\d+)\s+(?P<d>\S+)'
        re_air_dates = re.compile(r)
        
    for d in soup.find_all('tr', attrs={'id' : 'brow'}):
        t = ' '.join(d.text.split())
        m = re_air_dates.match(t)
        if not m:
            continue
        ep = 's%02de%02d' % (int(m.group('s')), int(m.group('e')))
        try:
            d = datetime.datetime.strptime(m.group('d'), '%d/%b/%Y')
        except:
            d = None
        log.debug("%s %s", ep, d)
        if not ep in eps:
            eps[ep] = new_ep()
        eps[ep]['air_date'] = d
        


############################################
# Main
############################################

def new_tv_show():
    tv = dict()
    tv['eps'] = {}
    tv['torrent_url'] = ''
    tv['sub_url'] = ''
    tv['dl_ep'] = 's00e00'
    return tv

def new_ep():
    ep = dict()
    ep['air_date'] = None
    ep['has_torrent'] = False
    ep['has_sub'] = False
    return ep

def update_tv_show(name, tv):
    log.debug('%s', name)
    update_air_dates(name, tv)
    update_torrents(name, tv)
    if args.subtitles:
        update_subtitles(name, tv)
    # log.debug('%s', pprint.pformat(tv))
    
def print_tv_show(tv):
    msg_dl = tv['dl_ep']
    if msg_dl == 's00e00':
        msg_dl = ''

    # find new episodes
    eps = tv['eps']
    ep_ids = [ ep_id for ep_id in sorted(eps) if ep_id > tv['dl_ep']]
    log.debug('eps %s', ep_ids)
    if not ep_ids:
        return (msg_dl, '')

    # find new episodes with torrents
    ss = []
    for ep_id in ep_ids:
        if not eps[ep_id]['has_torrent']:
            continue
        s = ep_id
        if eps[ep_id]['has_sub']:
            s += ' + subs'
        ss.append(s)
    if ss:
        if args.browser:
            if tv['torrent_url']:
                sp.Popen([xconf['browser'], tv['torrent_url']],
                         stderr = open('/dev/null', 'r'))
            if tv['sub_url']:
                sp.Popen([xconf['browser'], tv['sub_url']],
                         stderr = open('/dev/null', 'r'))
        return (msg_dl, ', '.join(ss))

    # find date of the next episode
    today = datetime.datetime.today()
    # msg_next = 'Next ' + ep_ids[0]
    msg_next = ''
    d = eps[ep_ids[0]]['air_date']
    if d:
        # msg_next += ' at ' + str(d.date())
        days = (d - today).days
        if days > 0:
            msg_next += 'in ' + str(days) + ' days'
        else:
            msg_next += 'soon'
    return (msg_dl, msg_next)

############################################
# Main
############################################
xconf = config_read()
if args.info:
    print config_file
    print pprint.pformat(xconf)
    exit(0)

tvs = {}

nlen = 0
if args.name:
    name = args.name
    name = ' '.join(name.split()).title()
    nlen = len(name)
    tv = new_tv_show()
    tvs[name] = tv
elif args.all:
    update_tvs_from_dl(xconf['tvs'])
    config_write(xconf)
    for name in sorted(xconf['tvs']):
        if nlen < len(name):
            nlen = len(name)
        # name = ' '.join(name.split()).title()
        tv = new_tv_show()
        tv['dl_ep'] = xconf['tvs'][name]
        tvs[name] = tv

if not tvs:
    exit(0)
    
nlen += 3
afmt = '%-' + str(nlen) + 's' + '%-9s%s'
indent = ' ' * (nlen + 9)
tw = textwrap.TextWrapper(width = 78,
                          replace_whitespace = False,
                          subsequent_indent = indent)

print "\033[1m" + (afmt % ('TV', 'Old', 'New')) + "\033[0m"
for name in sorted(tvs):
    print name, " ",
    sys.stdout.flush()
    update_tv_show(name, tvs[name])
    msg = afmt % ( (name,) + print_tv_show(tvs[name]) )
    msg = "\033[" + str(nlen) + "D" + tw.fill(msg)
    print msg
